/*
 * 	main.c
 *
 *  Created on: 22.07.2022
 *  Autho     : Беляев А.А.
 *
 *
 *	Описание  : MCUv7
 *
 *	Последнее редактирование: 24.08.2022
 *
 */
//*******************************************************************************************
//*******************************************************************************************

#include "main.h"

//*******************************************************************************************
//*******************************************************************************************

Button_t  PwrButton;

//*******************************************************************************************
//*******************************************************************************************
uint32_t Led_Blink(uint32_t millis, uint32_t period, uint32_t switch_on_time){

	static uint32_t millisOld = 0;
	static uint32_t flag      = 0;
	//-------------------
	if((millis - millisOld) >= (flag ? (period - switch_on_time) : switch_on_time))
	{
		millisOld = millis;
		flag = !flag;
	}
	return flag;
}
//************************************************************

//*******************************************************************************************
//*******************************************************************************************
void Task_ReadTemperature(void){

	TEMPERATURE_SENSE_Loop();
}
//************************************************************
//ф-я вызыввается каждые 100мс.
void Task_PwrButtonPolling(void){

//	static uint32_t buttonLongPressCount = 0;
//	//-------------------
//	if(GPIO_GetPinState(MCU_PWR_BTN_GPIO, MCU_PWR_BTN_PIN) == PIN_LOW)
//	{
//		buttonLongPressCount++;
//		//Отключение через секунду
//		if(buttonLongPressCount >= 10)
//		{
//			buttonLongPressCount = 0;
//			MCU_EN_Low();
//			FAN_EN_Low();
//			LAMP_PWM_Low();
//			LIDAR_EN_Low();
//			GPS_EN_Low();
//		}
//	}
//	else buttonLongPressCount = 0;
}
//*******************************************************************************************
//*******************************************************************************************
//*******************************************************************************************
//*******************************************************************************************
//Работа с энкодером AMM3617.Энкодер выдает 17-тибитный код Грея.
#define ENCODER_NUM_STEP 		65536//131072 					 //количество шагов энкодера на один оборот
#define ENCODER_DEGREE_QUANT  	(float)(360.0 / ENCODER_NUM_STEP)//количество градусов в одном наге энкодера.

//#define ENCODER_TIMEOUT 		(30 / 10)			      //деление на 10 так как uSecTick = 10 мкСек.
#define _RPM					60
#define QUANT_FOR_100mS     	((_RPM * (1000/100) * 1000) / 360.0)
#define QUANT_FOR_10mS      	((_RPM * (1000/10)  * 1000) / 360.0)
#define QUANT_FOR_64mS      	((_RPM * (1000/64)  * 1000) / 360.0)
//********************************************************
volatile uint32_t sysTick      		= 0;
volatile uint32_t EncoderTicks 		= 0;

volatile float Angle           		= 0.0;
volatile float OldAngle        		= 0.0;
volatile float DeltaAngle      		= 0.0;
volatile float RPM             		= 0.0;

uint8_t txBuf[64] = {0,};
//*******************************************************************************************
void BinToDecWithoutDot(uint32_t var, uint8_t* buf){

	*(buf+0) = (uint8_t)(var / 100000) + '0';
	var %= 100000;

	*(buf+1) = (uint8_t)(var / 10000) + '0';
	var %= 10000;

	*(buf+2) = (uint8_t)(var / 1000) + '0';
	var %= 1000;

	//*(buf+3) = ',';

	*(buf+3) = (uint8_t)(var / 100) + '0';
	var %= 100;

	*(buf+4) = (uint8_t)(var / 10) + '0';
	*(buf+5) = (uint8_t)(var % 10) + '0';
}
//************************************************************
void BinToDecWithDot(uint32_t var, uint8_t* buf){

	*(buf+0) = (uint8_t)(var / 100000) + '0';
	var %= 100000;

	*(buf+1) = (uint8_t)(var / 10000) + '0';
	var %= 10000;

	*(buf+2) = (uint8_t)(var / 1000) + '0';
	var %= 1000;

	*(buf+3) = ',';

	*(buf+4) = (uint8_t)(var / 100) + '0';
	var %= 100;

	*(buf+5) = (uint8_t)(var / 10) + '0';
	*(buf+6) = (uint8_t)(var % 10) + '0';
}
//************************************************************
void BuildAndSendTextBuf(uint32_t timeStamp, uint32_t encodTicks, uint32_t angle, uint32_t speed){

	BinToDecWithDot(timeStamp, txBuf);
	txBuf[7] = '\t';

	BinToDecWithoutDot(encodTicks, txBuf+8);
	txBuf[14] = '\t';

	BinToDecWithDot(angle, txBuf+15);
	txBuf[22] = '\t';

	BinToDecWithDot(speed, txBuf+23);
	txBuf[30] = '\r';

	DMA1Ch4StartTx(txBuf, 31);
}
//*******************************************************************************************
//*******************************************************************************************
//*******************************************************************************************
//*******************************************************************************************
void Task_Motor(void){

	//Пример расчета:
	//Макс.скорость - 10 RPM, это = 10*2*Pi = 62.8319 рад/мин, или 1,0472 рад/сек.   1,0472/ 0,01 = 104,72 ~ 105 (in 0.01*rad/sec).
	//Ускорение  - 20 RPM^2, это = 20*2*Pi = 125.6637 рад/мин^2, или 0,035 рад/сек^2. 0,035 / 0,01 = 3,49   ~ 3	 (in 0.01*rad/sec^2).
	//Замедление - 20 RPM^2, расчет тотже что и при ускорении.
	//Шаги - мне нужно повернуться на 360 градусов. Это 6400 шагов при microstep = 1/32

	// param step   Number of steps to move (pos - CW, neg - CCW).
	// param accel  Accelration to use, in 0.01*rad/sec^2.
	// param decel  Decelration to use, in 0.01*rad/sec^2.
	// param speed  Max speed, in 0.01*rad/sec.

	uint32_t RPM        = 100;     //Скорость оборотов в минуту
	uint32_t accel_RPMM = 360*10; //Ускорение оборотов в минуту за минуту
	uint32_t angle		= 120;    //Угол на который нужно переместить вал камеры в градусах.

	uint32_t microSteps        = (uint32_t)MOTOR_FULL_STEPS_PER_TURN * MOTOR_GetMicrostep();
	uint32_t steps			   = (uint32_t)(angle      * 6 * microSteps / (float)360.0);  //6 - передаточное число редуктора
	uint32_t vel_rad_per_sec   = (uint32_t)(RPM        * 2 * (float)3.14159 / 60   * 100);//скорость рад в сек
	uint32_t accel_rad_per_sec = (uint32_t)(accel_RPMM * 2 * (float)3.14159 / 3600 * 100);//Ускорение рад в секунду за секунд

	MOTOR_SpeedCntrMove(-1*steps, 		   //param step   Number of steps to move
						accel_rad_per_sec, //param accel  Accelration to use, in 0.01*rad/sec^2.
						accel_rad_per_sec, //param decel  Decelration to use, in 0.01*rad/sec^2.
						vel_rad_per_sec);  //param speed  Max speed, in 0.01*rad/sec.



//	static uint32_t flag = 0;
//	if(!flag)
//	{
//		flag = 1;
//		MOTOR_SpeedCntrMove(6400*6, 100, 100, 840);
//		//MOTOR_Move(360*5, 5, 100, 500);
//	}
//	else
//	{
//		flag = 0;
//		MOTOR_SpeedCntrMove(-6400*6, 100, 100, 840);
//		//MOTOR_Move(-360*5, 5, 100, 500);
//	}
}
//*******************************************************************************************
//*******************************************************************************************
//*******************************************************************************************
//*******************************************************************************************
int main(void){

	//***********************************************
	//Инициализация периферии STM32.
 	STM32_Clock_Init();
	GPIO_Init();
	MICRO_DELAY_Init();
	//***********************************************
	//Инициализация программного модуля работы с питанием MCU
	POWER_Init();
	//***********************************************
	//Инициализация кнопки.
	PwrButton.GPIO_PORT = MCU_PWR_BUTTON_GPIO;
	PwrButton.GPIO_PIN  = MCU_PWR_BUTTON_PIN;
	PwrButton.State		= BUTTON_RELEASE;
	BUTTON_Init(&PwrButton);
	//***********************************************
	MICRO_DELAY(100000);//100mS - Эта задержка нужна для стабилизации напряжения патания.
	//Включение питания платы.
	MCU_EN_High();
	FAN_EN_High();
	GPS_EN_High();
	LIDAR_EN_High();
//	LAMP_PWM_High();
	//MICRO_DELAY(100000);//Эта задержка нужна для стабилизации напряжения патания включенной приферии MCU.
	//***********************************************
//	TEMPERATURE_SENSE_Init();	//Инициализация датчиков температуры.
//	OPT_SENS_Init();			//Инициализация оптических дадчитков наличия крышки объетива и наличия АКБ.
//	PROTOCOL_I2C_Init();		//Инициализация протокола обмена.
	ENCODER_Init();				//Инициализация энкодера.
	USART_Init(USART1, 57600);	//
	//***********************************************
	//Инициализация	драйвера мотора.
	MOTOR_Init();

//	MOTOR_CalcAccelDecel(0, 300, 1500);
//	MOTOR_SpinStart(MOTOR_ACCEL);
	//MOTOR_SetMaxVelocity(400); //Задание скорости в RPM
	//***********************************************
	//Ини-я диспетчера.
	RTOS_Init();
	RTOS_SetTask(Task_ReadTemperature,  0, 1000);//запуск задачи через 0мс и спериодом повторения 1000мс
	RTOS_SetTask(Task_PwrButtonPolling, 0, 100); //запуск задачи через 0мс и спериодом повторения 100мс

	RTOS_SetTask(Task_Motor, 1000, 5000);
	//***********************************************
	SysTick_Init();
	__enable_irq();
	//**************************************************************
	while(1)
	{
		RTOS_DispatchLoop();
		//__WFI();//Sleep
	}
	//**************************************************************
}
//*******************************************************************************************
//*******************************************************************************************
//Прерывание каждую милисекунду.
void SysTick_IT_Handler(void){

	RTOS_TimerServiceLoop();
	msDelay_Loop();
	Blink_Loop();
	GPIO_CheckLoop();
	//--------------------------
	OPT_SENS_CheckLoop();		  //Опрос состояния сенсоров наличия крышки объектива и наличия АКБ.
	BUTTON_CheckLoop(&PwrButton); //Опрос кнопки.
	//**************************************************************
	//Работа с энкодером. Для отладки данные предаются по USART на кудахтер.
	static uint32_t mSecCount = 0;
	//Формирование таймстемпов
	sysTick++;
	if(sysTick > 999999) sysTick = 0;
	//--------------------------
	if(++mSecCount >= 100)
	{
		mSecCount = 0;

		//__disable_irq();
		//LED_ACT_High();
		//Чтение заначения энкодера. ~9,5 мкС
		EncoderTicks = ENCODER_GetCode();
		//LED_ACT_Low();
		//Расчет значений для расчета скрости.
		Angle = ENCODER_DEGREE_QUANT * EncoderTicks;  //расчет угла поворота вала энкодера.
		if(OldAngle > Angle) OldAngle -= 360.0;		  //Это нужно для корректного расчета скорости при переходе от 359 к 0 градусов.
		DeltaAngle = Angle - OldAngle;         		  //приращение угла

		//Расчет скорости вращения.
		RPM = DeltaAngle * QUANT_FOR_100mS;
		OldAngle = Angle;
		//Передаем данные по USART на кудахтер.
		BuildAndSendTextBuf(sysTick,
							EncoderTicks,
							(uint32_t)(Angle*1000),
							(uint32_t)(RPM*6)); //6 - это передаточное число редуктора.
		//__enable_irq();
	}
	//**************************************************************
}
//*******************************************************************************************
//*******************************************************************************************











